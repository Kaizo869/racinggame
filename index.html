<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Car Racing Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
            pointer-events: none;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #startScreen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-align: center;
        }
        #startScreen p {
            font-size: 1.5em;
            margin-bottom: 30px;
            text-align: center;
        }
        #startButton {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
        }
        .carSelection {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 30px;
            width: 80%;
        }
        .carOption {
            width: 100px;
            height: 100px;
            margin: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 5px;
            padding: 5px;
        }
        .carOption img {
            width: 80px;
            height: 80px;
            object-fit: contain;
        }
        .carOption span {
            margin-top: 5px;
            text-align: center;
        }
        
        /* Mobile controls */
        #mobileControls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-between;
            pointer-events: none;
        }
        .controlArea {
            width: 45%;
            height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        .controlButton {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 5px;
            user-select: none;
            -webkit-user-select: none;
        }
        .controlButton i {
            font-size: 24px;
            color: white;
        }
        .controlRow {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #resetButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        #handbrakeButton {
            position: absolute;
            bottom: 20px;
            right: 80px;
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            #controls {
                display: none;
            }
            #mobileControls {
                display: flex;
            }
            #hud {
                font-size: 14px;
            }
            #startScreen h1 {
                font-size: 2em;
            }
            #startScreen p {
                font-size: 1em;
            }
            .carSelection {
                width: 95%;
            }
            .carOption {
                width: 80px;
                height: 80px;
                margin: 5px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
</head>
<body>
    <div id="info">3D Car Racing Game</div>
    <div id="hud">
        Speed: <span id="speed">0</span> km/h<br>
        Lap: <span id="lap">0/3</span><br>
        Time: <span id="time">00:00.000</span>
    </div>
    <div id="controls">
        Controls:<br>
        W/↑ - Accelerate<br>
        S/↓ - Brake/Reverse<br>
        A/← - Turn Left<br>
        D/→ - Turn Right<br>
        R - Reset Car<br>
        Space - Handbrake
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div class="controlArea" id="steeringArea">
            <div class="controlRow">
                <div class="controlButton" id="leftButton">
                    <i class="fas fa-arrow-left"></i>
                </div>
                <div class="controlButton" id="rightButton">
                    <i class="fas fa-arrow-right"></i>
                </div>
            </div>
        </div>
        <div class="controlArea" id="accelerationArea">
            <div class="controlRow">
                <div class="controlButton" id="accelerateButton">
                    <i class="fas fa-arrow-up"></i>
                </div>
            </div>
            <div class="controlRow">
                <div class="controlButton" id="brakeButton">
                    <i class="fas fa-arrow-down"></i>
                </div>
            </div>
        </div>
        <div id="resetButton">
            <i class="fas fa-undo"></i>
        </div>
        <div id="handbrakeButton">
            <i class="fas fa-hand-paper"></i>
        </div>
    </div>
    
    <div id="startScreen">
        <h1>3D Car Racing Game</h1>
        <p>Complete 3 laps as fast as you can!</p>
        <h2>Select Your Car</h2>
        <div class="carSelection">
            <div class="carOption" data-car="default">
                <div style="width: 80px; height: 80px; background-color: #ff0000; display: flex; justify-content: center; align-items: center;">
                    <div style="width: 40px; height: 20px; background-color: #333;"></div>
                </div>
                <span>Default Car</span>
            </div>
            <div class="carOption" data-car="maruti">
                <div style="width: 80px; height: 80px; background-color: #0088ff; display: flex; justify-content: center; align-items: center;">
                    <div style="width: 40px; height: 20px; background-color: #333;"></div>
                </div>
                <span>Maruti 800</span>
            </div>
            <div class="carOption" data-car="honda">
                <div style="width: 80px; height: 80px; background-color: #ffaa00; display: flex; justify-content: center; align-items: center;">
                    <div style="width: 40px; height: 20px; background-color: #333;"></div>
                </div>
                <span>Honda NSX</span>
            </div>
            <div class="carOption" data-car="bmw_gtr">
                <div style="width: 80px; height: 80px; background-color: #00ff00; display: flex; justify-content: center; align-items: center;">
                    <div style="width: 40px; height: 20px; background-color: #333;"></div>
                </div>
                <span>BMW M3 GTR</span>
            </div>
            <div class="carOption" data-car="bmw_e46">
                <div style="width: 80px; height: 80px; background-color: #ffffff; display: flex; justify-content: center; align-items: center;">
                    <div style="width: 40px; height: 20px; background-color: #333;"></div>
                </div>
                <span>BMW E46</span>
            </div>
        </div>
        <button id="startButton">Start Race</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // Add event listeners for car selection
        document.addEventListener('DOMContentLoaded', function( ) {
            // Add click event listeners to car options
            const carOptions = document.querySelectorAll('.carOption');
            carOptions.forEach(option => {
                option.addEventListener('click', function() {
                    // Remove selected class from all options
                    carOptions.forEach(opt => {
                        opt.style.border = '2px solid transparent';
                    });
                    
                    // Add selected class to clicked option
                    this.style.border = '2px solid #4CAF50';
                    
                    // Update selected car
                    selectedCar = this.getAttribute('data-car');
                    console.log('Selected car:', selectedCar);
                    
                    // Preview the selected car
                    previewSelectedCar();
                });
            });
            
            // Select default car initially
            const defaultCar = document.querySelector('.carOption[data-car="default"]');
            if (defaultCar) {
                defaultCar.style.border = '2px solid #4CAF50';
            }
            
            // Set up mobile controls
            setupMobileControls();
            
            // Detect if device is mobile
            checkIfMobile();
        });
        
        // Function to check if the device is mobile
        function checkIfMobile() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            
            if (isMobile) {
                document.getElementById('mobileControls').style.display = 'flex';
                document.getElementById('controls').style.display = 'none';
            } else {
                document.getElementById('mobileControls').style.display = 'none';
                document.getElementById('controls').style.display = 'block';
            }
        }
        
        // Function to set up mobile controls
        function setupMobileControls() {
            // Acceleration button
            const accelerateButton = document.getElementById('accelerateButton');
            accelerateButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['w'] = true;
            });
            accelerateButton.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['w'] = false;
            });
            
            // Brake button
            const brakeButton = document.getElementById('brakeButton');
            brakeButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['s'] = true;
            });
            brakeButton.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['s'] = false;
            });
            
            // Left button
            const leftButton = document.getElementById('leftButton');
            leftButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['a'] = true;
            });
            leftButton.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['a'] = false;
            });
            
            // Right button
            const rightButton = document.getElementById('rightButton');
            rightButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['d'] = true;
            });
            rightButton.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['d'] = false;
            });
            
            // Reset button
            const resetButton = document.getElementById('resetButton');
            resetButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['r'] = true;
            });
            resetButton.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['r'] = false;
            });
            
            // Handbrake button
            const handbrakeButton = document.getElementById('handbrakeButton');
            handbrakeButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys[' '] = true;
            });
            handbrakeButton.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys[' '] = false;
            });
            
            // Prevent default touch behavior to avoid scrolling while playing
            document.addEventListener('touchmove', function(e) {
                if (gameStarted) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        // Function to preview the selected car
        function previewSelectedCar() {
            console.log("Previewing car:", selectedCar);
            
            // Hide all car models first
            Object.keys(carModels).forEach(carType => {
                if (carModels[carType]) {
                    carModels[carType].visible = false;
                }
            });
            
            // Show the selected car model if it's loaded
            if (carModels[selectedCar]) {
                carModels[selectedCar].visible = true;
                console.log(`${selectedCar} car model is now visible:`, carModels[selectedCar].visible);
                
                // Force update the scene
                if (renderer) {
                    renderer.render(scene, camera);
                }
            } else {
                console.log(`${selectedCar} car model not loaded yet for preview`);
                // If the selected model isn't loaded yet, show the default car
                if (carModels.default) {
                    carModels.default.visible = true;
                }
            }
        }
        
        // Game variables
        let scene, camera, renderer, controls;
        let car, track, skybox;
        let carModel, wheels = [];
        let carSpeed = 0, carMaxSpeed = 50;
        let acceleration = 0.2, deceleration = 0.1, brakeForce = 0.4;
        let steeringAngle = 0, maxSteeringAngle = Math.PI / 6;
        let steeringSpeed = 0.04;
        let carDirection = new THREE.Vector3(0, 0, 1);
        let carPosition = new THREE.Vector3(0, 0.5, 0);
        let carRotation = new THREE.Euler(0, 0, 0);
        let cameraOffset = new THREE.Vector3(0, 5, -10);
        let cameraLookAt = new THREE.Vector3(0, 0, 5);
        let clock = new THREE.Clock();
        let delta = 0;
        let keys = {};
        let gameStarted = false;
        let gameTime = 0;
        let currentLap = 0;
        let checkpoints = [];
        let currentCheckpoint = 0;
        let lapStartTime = 0;
        let bestLapTime = Infinity;
        let particles = [];
        let exhaustParticles = [];

        // Track waypoints for AI and checkpoints
        const trackWaypoints = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(50, 0, 50),
            new THREE.Vector3(100, 0, 0),
            new THREE.Vector3(50, 0, -50),
            new THREE.Vector3(-50, 0, -50),
            new THREE.Vector3(-100, 0, 0),
            new THREE.Vector3(-50, 0, 50)
        ];

        // Car models
        const carModels = {
            default: null
        };
        let selectedCar = "default";
        let cityModel = null;
        
        // Initialize the game
        init();

        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Add orbit controls for debugging
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enabled = false; // Disable for gameplay, enable for debugging
            
            // Create lighting
            createLighting();
            
            // Create skybox
            createSkybox();
            
            // Create track
            createTrack();
            
            // Create car
            createCar();
            
            // Create checkpoints
            createCheckpoints();
            
            // Create HUD
            createHUD();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Start button event listener
            document.getElementById('startButton').addEventListener('click', startGame);
            
            // Start animation loop
            animate();
            
            // Call previewSelectedCar after initialization
            setTimeout(previewSelectedCar, 2000);
        }
        
        function createTrack() {
            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a5e1a,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Load city model
            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load('models/ccity_building_set_1.glb', function(gltf) {
                cityModel = gltf.scene;
                
                // Scale and position the city model
                cityModel.scale.set(10, 10, 10);
                cityModel.position.set(0, 0, -100);
                
                // Add shadows to all city meshes
                cityModel.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                scene.add(cityModel);
                console.log("City model loaded and added to scene");
                
                // Debug city model
                console.log("City model details:", {
                    position: cityModel.position,
                    scale: cityModel.scale,
                    visible: cityModel.visible,
                    childCount: cityModel.children.length
                });
            }, undefined, function(error) {
                console.error('Error loading city model:', error);
            });

            // Create race track
            const trackShape = new THREE.Shape();
            trackShape.moveTo(0, 0);
            trackShape.absarc(0, 0, 50, 0, Math.PI * 2, false);
            
            const hole = new THREE.Path();
            hole.absarc(0, 0, 40, 0, Math.PI * 2, true);
            trackShape.holes.push(hole);
            
            const trackGeometry = new THREE.ShapeGeometry(trackShape);
            const trackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.2
            });
            track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.rotation.x = -Math.PI / 2;
            track.receiveShadow = true;
            scene.add(track);
            
            // Create start/finish line
            const startLineGeometry = new THREE.PlaneGeometry(10, 2);
            const startLineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.5,
                metalness: 0.2
            });
            const startLine = new THREE.Mesh(startLineGeometry, startLineMaterial);
            startLine.position.set(0, 0.01, 45);
            startLine.rotation.x = -Math.PI / 2;
            startLine.receiveShadow = true;
            scene.add(startLine);
            
            // Create checkered pattern for start/finish
            const checkerSize = 1;
            const checkerRows = 2;
            const checkerCols = 10;
            
            for (let i = 0; i < checkerRows; i++) {
                for (let j = 0; j < checkerCols; j++) {
                    if ((i + j) % 2 === 0) continue;
                    
                    const checkerGeometry = new THREE.PlaneGeometry(checkerSize, checkerSize);
                    const checkerMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                    const checker = new THREE.Mesh(checkerGeometry, checkerMaterial);
                    
                    checker.position.set(
                        -5 + j * checkerSize + checkerSize / 2,
                        0.02,
                        45 - i * checkerSize - checkerSize / 2
                    );
                    checker.rotation.x = -Math.PI / 2;
                    checker.receiveShadow = true;
                    scene.add(checker);
                }
            }
            
            // Add track decorations
            addTrackDecorations();
        }
        
        function addTrackDecorations() {
            // Add trees around the track
            const treeCount = 30;
            const treeRadius = 80;
            
            for (let i = 0; i < treeCount; i++) {
                const angle = (i / treeCount) * Math.PI * 2;
                const x = Math.cos(angle) * treeRadius;
                const z = Math.sin(angle) * treeRadius;
                
                createTree(x, z);
            }
            
            // Add random trees
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 200 - 100;
                const z = Math.random() * 200 - 100;
                const distance = Math.sqrt(x * x + z * z);
                
                if (distance > 60 && distance < 150) {
                    createTree(x, z);
                }
            }
            
            // Add rocks
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 200 - 100;
                const z = Math.random() * 200 - 100;
                const distance = Math.sqrt(x * x + z * z);
                
                if (distance > 60 && distance < 150) {
                    createRock(x, z);
                }
            }
        }
        
        function createTree(x, z) {
            // Create tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 3, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1.5, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            scene.add(trunk);
            
            // Create tree top
            const topGeometry = new THREE.ConeGeometry(2, 4, 8);
            const topMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2E8B57,
                roughness: 0.8,
                metalness: 0.2
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(x, 5, z);
            top.castShadow = true;
            top.receiveShadow = true;
            scene.add(top);
        }
        
        function createRock(x, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 1, 0);
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                roughness: 0.9,
                metalness: 0.1
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            
            rock.position.set(x, Math.random() * 0.5 + 0.5, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.scale.set(
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5,
                Math.random() * 0.5 + 0.5
            );
            
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
        }
        
        function createCar() {
            // Load car models
            loadCarModels();
            
            // Create default car model (simple geometry)
            createDefaultCar();
        }
        
        function loadCarModels() {
            const gltfLoader = new THREE.GLTFLoader();
            const modelPaths = {
                maruti: 'models/maruti_800_ac.glb',
                honda: 'models/honda_nsx_1990.glb',
                bmw_gtr: 'models/2005_bmw_m3_e46_gtr_-_nfs_most_wanted (1).glb',
                bmw_e46: 'models/bmw_e46_m3_nightryder_sports_car.glb'
            };
            
            // Car model configurations (scale, position, rotation)
            const modelConfigs = {
                maruti: { scale: 0.5, position: [0, 1.5, 0], rotation: [0, Math.PI, 0] },
                honda: { scale: 1.0, position: [0, 1.5, 0], rotation: [0, Math.PI, 0] },
                bmw_gtr: { scale: 1.0, position: [0, 1.5, 0], rotation: [0, Math.PI, 0] },
                bmw_e46: { scale: 1.0, position: [0, 1.5, 0], rotation: [0, Math.PI, 0] }
            };
            
            // Load each model
            Object.keys(modelPaths).forEach(carType => {
                gltfLoader.load(modelPaths[carType], function(gltf) {
                    const model = gltf.scene;
                    const config = modelConfigs[carType];
                    
                    // Apply configuration
                    model.scale.set(config.scale, config.scale, config.scale);
                    model.position.set(...config.position);
                    model.rotation.set(...config.rotation);
                    
                    // Add shadows to all meshes
                    model.traverse(function(node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    
                    // Store the model
                    carModels[carType] = model;
                    console.log(`${carType} model loaded with scale ${config.scale} at position ${config.position}`);
                    
                    // Hide the model initially
                    model.visible = false;
                    scene.add(model);
                    
                    // If this is the currently selected car, preview it
                    if (carType === selectedCar) {
                        previewSelectedCar();
                    }
                    
                    // Debug model details
                    console.log(`${carType} model details:`, {
                        position: model.position,
                        scale: model.scale,
                        visible: model.visible,
                        childCount: model.children.length
                    });
                    
                }, undefined, function(error) {
                    console.error(`Error loading ${carType} model:`, error);
                });
            });
        }
        
        function createDefaultCar() {
            // Create a simple car model
            const carGroup = new THREE.Group();
            
            // Car body
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                roughness: 0.5,
                metalness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            body.receiveShadow = true;
            carGroup.add(body);
            
            // Car cabin
            const cabinGeometry = new THREE.BoxGeometry(1.5, 0.8, 2);
            const cabinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.2
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1.4, 0);
            cabin.castShadow = true;
            cabin.receiveShadow = true;
            carGroup.add(cabin);
            
            // Car wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Front left wheel
            const wheelFL = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFL.position.set(-1.2, 0.5, 1.2);
            wheelFL.rotation.z = Math.PI / 2;
            wheelFL.castShadow = true;
            wheelFL.receiveShadow = true;
            carGroup.add(wheelFL);
            wheels.push(wheelFL);
            
            // Front right wheel
            const wheelFR = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFR.position.set(1.2, 0.5, 1.2);
            wheelFR.rotation.z = Math.PI / 2;
            wheelFR.castShadow = true;
            wheelFR.receiveShadow = true;
            carGroup.add(wheelFR);
            wheels.push(wheelFR);
            
            // Rear left wheel
            const wheelRL = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelRL.position.set(-1.2, 0.5, -1.2);
            wheelRL.rotation.z = Math.PI / 2;
            wheelRL.castShadow = true;
            wheelRL.receiveShadow = true;
            carGroup.add(wheelRL);
            wheels.push(wheelRL);
            
            // Rear right wheel
            const wheelRR = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelRR.position.set(1.2, 0.5, -1.2);
            wheelRR.rotation.z = Math.PI / 2;
            wheelRR.castShadow = true;
            wheelRR.receiveShadow = true;
            carGroup.add(wheelRR);
            wheels.push(wheelRR);
            
            // Headlights
            const headlightGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.1);
            const headlightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffcc,
                emissive: 0xffffcc,
                emissiveIntensity: 0.5
            });
            
            // Left headlight
            const headlightL = new THREE.Mesh(headlightGeometry, headlightMaterial);
            headlightL.position.set(-0.6, 0.7, 2);
            carGroup.add(headlightL);
            
            // Right headlight
            const headlightR = new THREE.Mesh(headlightGeometry, headlightMaterial);
            headlightR.position.set(0.6, 0.7, 2);
            carGroup.add(headlightR);
            
            // Taillights
            const taillightGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.1);
            const taillightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            });
            
            // Left taillight
            const taillightL = new THREE.Mesh(taillightGeometry, taillightMaterial);
            taillightL.position.set(-0.6, 0.7, -2);
            carGroup.add(taillightL);
            
            // Right taillight
            const taillightR = new THREE.Mesh(taillightGeometry, taillightMaterial);
            taillightR.position.set(0.6, 0.7, -2);
            carGroup.add(taillightR);
            
            // Add car to scene
            carGroup.position.set(0, 0, 45);
            carGroup.rotation.y = Math.PI;
            scene.add(carGroup);
            
            // Store the default car model
            carModels.default = carGroup;
            carModel = carGroup;
            car = carGroup;
        }
        
        function createLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            
            // Configure shadow properties
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            
            scene.add(directionalLight);
            
            // Add hemisphere light for better ambient lighting
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
            scene.add(hemisphereLight);
        }
        
        function createSkybox() {
            // Create a large sphere for the sky
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            
            // Create gradient material
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },
                    bottomColor: { value: new THREE.Color(0xffffff) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            
            skybox = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skybox);
            
            // Add clouds
            createClouds();
        }
        
        function createClouds() {
            const cloudCount = 20;
            const cloudGeometry = new THREE.SphereGeometry(10, 8, 8);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                roughness: 1,
                metalness: 0
            });
            
            for (let i = 0; i < cloudCount; i++) {
                const cloudGroup = new THREE.Group();
                
                // Create cloud cluster
                const clusterCount = Math.floor(Math.random() * 5) + 3;
                
                for (let j = 0; j < clusterCount; j++) {
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    
                    cloud.position.set(
                        Math.random() * 15 - 7.5,
                        Math.random() * 5 - 2.5,
                        Math.random() * 15 - 7.5
                    );
                    
                    cloud.scale.set(
                        Math.random() * 0.5 + 0.5,
                        Math.random() * 0.3 + 0.3,
                        Math.random() * 0.5 + 0.5
                    );
                    
                    cloudGroup.add(cloud);
                }
                
                // Position the cloud group
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 200 + 200;
                const height = Math.random() * 100 + 50;
                
                cloudGroup.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                scene.add(cloudGroup);
            }
        }
        
        function createCheckpoints() {
            // Create checkpoints based on track waypoints
            for (let i = 0; i < trackWaypoints.length; i++) {
                const checkpoint = new THREE.Object3D();
                checkpoint.position.copy(trackWaypoints[i]);
                checkpoint.position.y = 0.1;
                
                // Create invisible checkpoint marker
                const markerGeometry = new THREE.CylinderGeometry(5, 5, 10, 16, 1, true);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.visible = false; // Make invisible for gameplay
                checkpoint.add(marker);
                
                checkpoints.push(checkpoint);
                scene.add(checkpoint);
            }
        }
        
        function createHUD() {
            // HUD elements are created in HTML
        }
        
        function startGame() {
            // Hide start screen
            document.getElementById('startScreen').style.display = 'none';
            
            // Reset game state
            gameStarted = true;
            gameTime = 0;
            currentLap = 0;
            currentCheckpoint = 0;
            lapStartTime = 0;
            bestLapTime = Infinity;
            
            // Reset car position
            resetCar();
            
            // Update HUD
            updateHUD();
            
            // Switch to the selected car model
            switchToSelectedCar();
            
            console.log("Game started with car:", selectedCar);
        }
        
        function switchToSelectedCar() {
            // Hide all car models
            Object.keys(carModels).forEach(carType => {
                if (carModels[carType]) {
                    carModels[carType].visible = false;
                }
            });
            
            // Show the selected car model
            if (carModels[selectedCar]) {
                carModels[selectedCar].visible = true;
                carModel = carModels[selectedCar];
                car = carModel;
                
                // Count wheels for physics
                let wheelCount = 0;
                carModel.traverse(function(node) {
                    if (node.isMesh && node.name.toLowerCase().includes('wheel')) {
                        wheelCount++;
                    }
                });
                
                console.log(`Switched to ${selectedCar} car model with ${wheelCount} wheels`);
            } else {
                console.log(`${selectedCar} car model not loaded, using default`);
                carModels.default.visible = true;
                carModel = carModels.default;
                car = carModel;
            }
            
            // Reset car position
            resetCar();
        }
        
        function resetCar() {
            // Reset car position and rotation
            carPosition.set(0, 0.5, 45);
            carRotation.set(0, Math.PI, 0);
            carDirection.set(0, 0, 1);
            
            // Reset car physics
            carSpeed = 0;
            steeringAngle = 0;
            
            // Update car model position
            updateCar();
        }
        
        function updateCar() {
            if (!gameStarted) return;
            
            // Apply steering
            if (keys['ArrowLeft'] || keys['a']) {
                steeringAngle += steeringSpeed * delta;
                if (steeringAngle > maxSteeringAngle) steeringAngle = maxSteeringAngle;
            } else if (keys['ArrowRight'] || keys['d']) {
                steeringAngle -= steeringSpeed * delta;
                if (steeringAngle < -maxSteeringAngle) steeringAngle = -maxSteeringAngle;
            } else {
                // Return steering to center
                if (steeringAngle > 0) {
                    steeringAngle -= steeringSpeed * delta * 2;
                    if (steeringAngle < 0) steeringAngle = 0;
                } else if (steeringAngle < 0) {
                    steeringAngle += steeringSpeed * delta * 2;
                    if (steeringAngle > 0) steeringAngle = 0;
                }
            }
            
            // Apply acceleration/braking
            if (keys['ArrowUp'] || keys['w']) {
                carSpeed += acceleration * delta;
                if (carSpeed > carMaxSpeed) carSpeed = carMaxSpeed;
            } else if (keys['ArrowDown'] || keys['s']) {
                carSpeed -= brakeForce * delta;
                if (carSpeed < -carMaxSpeed / 2) carSpeed = -carMaxSpeed / 2;
            } else {
                // Apply natural deceleration
                if (carSpeed > 0) {
                    carSpeed -= deceleration * delta;
                    if (carSpeed < 0) carSpeed = 0;
                } else if (carSpeed < 0) {
                    carSpeed += deceleration * delta;
                    if (carSpeed > 0) carSpeed = 0;
                }
            }
            
            // Apply handbrake
            if (keys[' ']) {
                carSpeed *= 0.95;
                steeringAngle *= 1.5; // Increase steering effect during handbrake
            }
            
            // Reset car position if R key is pressed
            if (keys['r']) {
                resetCar();
                return;
            }
            
            // Update car direction based on steering
            if (carSpeed != 0) {
                // Calculate steering effect based on speed
                const steeringEffect = steeringAngle * (Math.abs(carSpeed) / carMaxSpeed) * 0.5;
                
                // Rotate car direction
                carRotation.y += steeringEffect * delta;
                
                // Update car direction vector
                carDirection.set(0, 0, 1).applyEuler(carRotation);
            }
            
            // Move car based on speed and direction
            carPosition.add(carDirection.clone().multiplyScalar(carSpeed * delta));
            
            // Update car model position and rotation
            if (car) {
                car.position.copy(carPosition);
                car.rotation.copy(carRotation);
                
                // Rotate wheels
                if (wheels.length > 0) {
                    // Rotate front wheels for steering
                    wheels[0].rotation.y = steeringAngle;
                    wheels[1].rotation.y = steeringAngle;
                    
                    // Rotate all wheels for movement
                    const wheelRotationSpeed = carSpeed * delta * 2;
                    wheels.forEach(wheel => {
                        wheel.rotation.x += wheelRotationSpeed;
                    });
                }
            }
            
            // Check for checkpoint crossing
            checkCheckpoints();
            
            // Create particles
            if (Math.abs(carSpeed) > carMaxSpeed * 0.7 && Math.abs(steeringAngle) > maxSteeringAngle * 0.7) {
                createTireSmoke();
            }
            
            if (carSpeed > carMaxSpeed * 0.8) {
                createExhaustParticles();
            }
            
            // Update camera position
            updateCamera();
        }
        
        function updateCamera() {
            // Calculate ideal camera position based on car
            const idealOffset = cameraOffset.clone().applyEuler(carRotation);
            const idealLookAt = cameraLookAt.clone().applyEuler(carRotation);
            
            // Set camera position and lookAt
            camera.position.copy(carPosition).add(idealOffset);
            camera.lookAt(carPosition.clone().add(idealLookAt));
        }
        
        function checkCheckpoints() {
            // Get current checkpoint
            const checkpoint = checkpoints[currentCheckpoint];
            
            // Calculate distance to checkpoint
            const distance = carPosition.distanceTo(checkpoint.position);
            
            // Check if car has reached checkpoint
            if (distance < 10) {
                // Move to next checkpoint
                currentCheckpoint = (currentCheckpoint + 1) % checkpoints.length;
                
                // Check if completed a lap
                if (currentCheckpoint === 0) {
                    completeLap();
                }
            }
        }
        
        function completeLap() {
            // Increment lap counter
            currentLap++;
            
            // Calculate lap time
            const lapTime = gameTime - lapStartTime;
            lapStartTime = gameTime;
            
            // Check if this is the best lap
            if (lapTime < bestLapTime && currentLap > 1) {
                bestLapTime = lapTime;
            }
            
            // Update HUD
            updateHUD();
            
            // Check if race is complete
            if (currentLap >= 3) {
                finishRace();
            }
        }
        
        function finishRace() {
            // Display finish message
            alert(`Race complete!\nTotal time: ${formatTime(gameTime)}\nBest lap: ${formatTime(bestLapTime)}`);
            
            // Reset game
            gameStarted = false;
            document.getElementById('startScreen').style.display = 'flex';
        }
        
        function createTireSmoke() {
            // Create tire smoke particles at wheel positions
            if (wheels.length > 0) {
                wheels.forEach(wheel => {
                    const worldPosition = new THREE.Vector3();
                    wheel.getWorldPosition(worldPosition);
                    
                    const particle = {
                        position: worldPosition.clone(),
                        size: Math.random() * 0.5 + 0.5,
                        opacity: 1,
                        life: 1
                    };
                    
                    particles.push(particle);
                    
                    // Create particle mesh
                    const particleGeometry = new THREE.PlaneGeometry(particle.size, particle.size);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: 0xcccccc,
                        transparent: true,
                        opacity: particle.opacity
                    });
                    const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
                    
                    particleMesh.position.copy(particle.position);
                    particleMesh.rotation.copy(camera.rotation);
                    
                    scene.add(particleMesh);
                    
                    // Store mesh with particle
                    particle.mesh = particleMesh;
                });
            }
        }
        
        function createExhaustParticles() {
            // Create exhaust particles
            const exhaustPosition = carPosition.clone().add(
                new THREE.Vector3(0, 0.5, -2).applyEuler(carRotation)
            );
            
            const particle = {
                position: exhaustPosition,
                velocity: new THREE.Vector3(
                    Math.random() * 0.2 - 0.1,
                    Math.random() * 0.2 + 0.1,
                    Math.random() * 0.2 - 0.1
                ),
                size: Math.random() * 0.3 + 0.2,
                opacity: 0.7,
                life: 1
            };
            
            exhaustParticles.push(particle);
            
            // Create particle mesh
            const particleGeometry = new THREE.PlaneGeometry(particle.size, particle.size);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x333333,
                transparent: true,
                opacity: particle.opacity
            });
            const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
            
            particleMesh.position.copy(particle.position);
            particleMesh.rotation.copy(camera.rotation);
            
            scene.add(particleMesh);
            
            // Store mesh with particle
            particle.mesh = particleMesh;
        }
        
        function updateParticles() {
            // Update tire smoke particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Update life
                particle.life -= delta;
                
                // Update opacity
                particle.opacity = particle.life;
                
                if (particle.mesh) {
                    particle.mesh.material.opacity = particle.opacity;
                    particle.mesh.rotation.copy(camera.rotation);
                }
                
                // Remove dead particles
                if (particle.life <= 0) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                    particles.splice(i, 1);
                }
            }
            
            // Update exhaust particles
            for (let i = exhaustParticles.length - 1; i >= 0; i--) {
                const particle = exhaustParticles[i];
                
                // Update position
                particle.position.add(particle.velocity);
                
                // Update life
                particle.life -= delta * 2;
                
                // Update opacity
                particle.opacity = particle.life * 0.7;
                
                if (particle.mesh) {
                    particle.mesh.position.copy(particle.position);
                    particle.mesh.material.opacity = particle.opacity;
                    particle.mesh.rotation.copy(camera.rotation);
                }
                
                // Remove dead particles
                if (particle.life <= 0) {
                    if (particle.mesh) {
                        scene.remove(particle.mesh);
                    }
                    exhaustParticles.splice(i, 1);
                }
            }
        }
        
        function updateHUD() {
            // Update speed display
            document.getElementById('speed').textContent = Math.abs(Math.round(carSpeed * 20));
            
            // Update lap display
            document.getElementById('lap').textContent = `${currentLap}/3`;
            
            // Update time display
            document.getElementById('time').textContent = formatTime(gameTime);
        }
        
        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time % 1) * 1000);
            
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update delta time
            delta = clock.getDelta();
            
            // Update game time if game is started
            if (gameStarted) {
                gameTime += delta;
            }
            
            // Update car
            updateCar();
            
            // Update particles
            updateParticles();
            
            // Update HUD
            if (gameStarted) {
                updateHUD();
            }
            
            // Update controls if enabled
            if (controls && controls.enabled) {
                controls.update();
            }
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Check if mobile
            checkIfMobile();
        }
        
        function onKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
        }
        
        function onKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }
    </script>
</body>
</html>
